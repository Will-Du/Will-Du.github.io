<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  <title>面试题-并发与线程 | 嘟嘟的博客</title>

  <!-- keywords -->
  

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="1.线程有那些状态？&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;新建状态：当用new操作符创建一个线程时。此时程序还没有开始运行线程中的代码。&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;就绪状态：一个新创建的线程并不自动开始运行，要执行线程，必须调用线程的start()方法。当线程对象调用start()方法即启动了线程，start()方法创建线程运行的系统资源，并调度线程运行run()方法">
<meta name="keywords" content="面试题">
<meta property="og:type" content="article">
<meta property="og:title" content="面试题-并发与线程">
<meta property="og:url" content="http://yoursite.com/2019/11/07/interview_并发与线程/index.html">
<meta property="og:site_name" content="嘟嘟的博客">
<meta property="og:description" content="1.线程有那些状态？&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;新建状态：当用new操作符创建一个线程时。此时程序还没有开始运行线程中的代码。&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;就绪状态：一个新创建的线程并不自动开始运行，要执行线程，必须调用线程的start()方法。当线程对象调用start()方法即启动了线程，start()方法创建线程运行的系统资源，并调度线程运行run()方法">
<meta property="og:locale" content="default">
<meta property="og:updated_time" content="2020-01-22T06:17:56.630Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="面试题-并发与线程">
<meta name="twitter:description" content="1.线程有那些状态？&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;新建状态：当用new操作符创建一个线程时。此时程序还没有开始运行线程中的代码。&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;就绪状态：一个新创建的线程并不自动开始运行，要执行线程，必须调用线程的start()方法。当线程对象调用start()方法即启动了线程，start()方法创建线程运行的系统资源，并调度线程运行run()方法">
  
    <link rel="alternative" href="/atom.xml" title="嘟嘟的博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/img/kenan.jpg">
  
  <link rel="stylesheet" href="/css/style.css">
  
  

  <script src="//cdn.bootcss.com/require.js/2.3.2/require.min.js"></script>
  <script src="//cdn.bootcss.com/jquery/3.1.1/jquery.min.js"></script>

  
      <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"></script>
<script>AV.initialize("1KJk8n1Nj4CXCkkWBlybrOrW-gzGzoHsz", "2un8yqP38AAz4m32MnsGrv49");</script>
<script src="/js/Counter.js"></script>
  
</head></html>
<body>
  <div id="container">
    <div id="particles-js"></div>
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="/img/photo.jpg" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">Will Wu</a></h1>
		</hgroup>

		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/Redis/" style="font-size: 10px;">Redis</a> <a href="/tags/Spring/" style="font-size: 10px;">Spring</a> <a href="/tags/css/" style="font-size: 10px;">css</a> <a href="/tags/java/" style="font-size: 18px;">java</a> <a href="/tags/jquery/" style="font-size: 12px;">jquery</a> <a href="/tags/js/" style="font-size: 14px;">js</a> <a href="/tags/linux/" style="font-size: 10px;">linux</a> <a href="/tags/nginx/" style="font-size: 10px;">nginx</a> <a href="/tags/sql/" style="font-size: 16px;">sql</a> <a href="/tags/微服务/" style="font-size: 10px;">微服务</a> <a href="/tags/数据库/" style="font-size: 10px;">数据库</a> <a href="/tags/设计模式/" style="font-size: 12px;">设计模式</a> <a href="/tags/递归算法/" style="font-size: 10px;">递归算法</a> <a href="/tags/面试题/" style="font-size: 20px;">面试题</a>
					</div>
				</section>
				
				
				

				
			</div>
		</div>
	</header>				
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">Will Wu</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img lazy-src="/img/photo.jpg" class="js-avatar">
			</div>
			<hgroup>
			  <h1 class="header-author">Will Wu</h1>
			</hgroup>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
				</div>
			</nav>
		</header>				
	</div>
</nav>
      <div class="body-wrap"><article id="post-interview_并发与线程" class="article article-type-post" itemscope="" itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2019/11/07/interview_并发与线程/" class="article-date">
  	<time datetime="2019-11-07T00:11:11.000Z" itemprop="datePublished">2019-11-07</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      面试题-并发与线程
      
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/面试题/">面试题</a></li></ul>
	</div>

        

        
          
<div class="counter-tag counter">
    <span id="/2019/11/07/interview_并发与线程/" class="leancloud_visitors post-title-link" style="font-size: 12px" data-flag-title="面试题-并发与线程">
         &nbsp;
        view
    </span>
</div>

        
        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><b style="color: #6A6AFF">1.线程有那些状态？</b><br>&nbsp;&nbsp;&nbsp;&nbsp;新建状态：当用new操作符创建一个线程时。此时程序还没有开始运行线程中的代码。<br>&nbsp;&nbsp;&nbsp;&nbsp;就绪状态：一个新创建的线程并不自动开始运行，要执行线程，必须调用线程的start()方法。当线程对象调用start()方法即启动了线程，start()方法创建线程运行的系统资源，并调度线程运行run()方法。当start()方法返回后，线程就处于就绪状态。处于就绪状态的线程并不一定立即运行run()方法，线程还必须同其他线程竞争CPU时间，只有获得CPU时间才可以运行线程。因为在单CPU的计算机系统中，不可能同时运行多个线程，一个时刻仅有一个线程处于运行状态。因此此时可能有多个线程处于就绪状态。对多个处于就绪状态的线程是由Java运行时系统的线程调度程序来调度的。<br>&nbsp;&nbsp;&nbsp;&nbsp;运行状态：当线程获得CPU时间后，它才进入运行状态，真正开始执行run()方法<br>&nbsp;&nbsp;&nbsp;&nbsp;阻塞状态：所谓阻塞状态是正在运行的线程没有运行结束，暂时让出CPU，这时其他处于就绪状态的线程就可以获得CPU时间，进入运行状态。线程运行过程中，可能由于各种原因进入阻塞状态：①线程通过调用sleep方法进入睡眠状态；②线程调用一个在I/O上被阻塞的操作，即该操作在输入输出操作完成之前不会返回到它的调用者；③线程试图得到一个锁，而该锁正被其他线程持有；④线程在等待某个触发条件。<br>&nbsp;&nbsp;&nbsp;&nbsp;死亡状态：有两个原因会导致线程死亡：①run方法正常退出而自然死亡；②一个未捕获的异常终止了run方法而使线程猝死；<br>&nbsp;&nbsp;&nbsp;&nbsp;等待状态：或者叫条件等待状态，当线程的运行条件不满足时，通过锁的条件等待机制(调用锁对象的wait()或显示锁条件对象的wait()方法)让线程进入等待状态。处于等待状态的线程将不会被CPU执行，除非线程的运行条件得到满足后，其可被其它线程唤醒，进入阻塞状态。调用不带超时的Thread.join()方法也会进入等待状态。<br>&nbsp;&nbsp;&nbsp;&nbsp;限时等待状态：是等待状态的一种特例，线程在等待时我们将设定等待时间，如超过了我们设定的时间，等待线程将自动唤醒进入阻塞状态或就绪状态。在调用Thread.sleep()方法、带有超时设定的Object.wait()、带有超时设定的thread.join()方法等，线程会进入限时等待状态。<br><a id="more"></a><br><b style="color: #6A6AFF">2.异步，同步，阻塞，非阻塞的区别</b><br>&nbsp;&nbsp;&nbsp;&nbsp;同步和异步是针对应用程序和内核的交互而言的，同步指的是用户进程触发IO操作并等待或者轮询的去查看IO操作是否就绪，而异步是指用户进程触发IO操作以后便开始做自己的事情，而当IO操作已经完成的时候会得到IO完成的通知（异步的特点就是通知）。而阻塞和非阻塞是针对于进程在访问数据的时候，根据IO操作的就绪状态来采取的不同方式，说白了是一种读取或者写入操作函数的实现方式，阻塞方式下读取或者写入函数将一直等待，而非阻塞方式下，读取或者写入函数会立即返回一个状态值。<br><b style="color: #6A6AFF">3.并发与并行的区别</b><br>&nbsp;&nbsp;&nbsp;&nbsp;并发：同一时间段，多个任务都在执行 (单位时间内不一定同时执行)<br>&nbsp;&nbsp;&nbsp;&nbsp;并行：单位时间内，多个任务同时执行。<br><b style="color: #6A6AFF">4.如何避免线程死锁</b><br>&nbsp;&nbsp;&nbsp;&nbsp;破坏互斥条件：这个条件我们没有办法破坏，因为我们用锁本来就是想让他们互斥的（临界资源需要互斥访问）。<br>&nbsp;&nbsp;&nbsp;&nbsp;破坏请求与保持条件：一次性申请所有的资源<br>&nbsp;&nbsp;&nbsp;&nbsp;破坏不剥夺条件：占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源<br>&nbsp;&nbsp;&nbsp;&nbsp;破坏循环等待条件：靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。<br><b style="color: #6A6AFF">5.乐观锁与悲观锁的区别及使用场景</b><br>&nbsp;&nbsp;乐观锁:每次获取数据的时候，都不会担心数据被修改，所以每次获取数据的时候都不会进行加锁，但是在更新数据的时候需要判断该数据是否被别人修改过。如果数据被其他线程修改，则不进行数据更新，如果数据没有被其他线程修改，则进行数据更新。由于数据没有进行加锁，期间该数据可以被其他线程进行读写操作。一般使用version方式和CAS操作方式。<br>&nbsp;&nbsp;&nbsp;&nbsp;使用场景：比较适合读取操作比较频繁的场景，如果出现大量的写入操作，数据发生冲突的可能性就会增大，为了保证数据的一致性，应用层需要不断的重新获取数据，这样会增加大量的查询操作，降低了系统的吞吐量。<br>&nbsp;&nbsp;悲观锁：每次获取数据的时候，都会担心数据被修改，所以每次获取数据的时候都会进行加锁，确保在自己使用的过程中数据不会被别人修改，使用完成后进行数据解锁。由于数据进行加锁，期间对该数据进行读写的其他线程都会进行等待。在Java中，synchronized的思想也是悲观锁。<br>&nbsp;&nbsp;&nbsp;&nbsp;使用场景：比较适合写入操作比较频繁的场景，如果出现大量的读取操作，每次读取的时候都会进行加锁，这样会增加大量的锁的开销，降低了系统的吞吐量。<br><b style="color: #6A6AFF">6. sleep() 方法和 wait() 方法区别和共同点</b><br>&nbsp;&nbsp;&nbsp;&nbsp;区别：1.sleep 方法没有释放锁，而 wait 方法释放了锁 2.Wait 通常被用于线程间交互/通信，sleep 通常被用于暂停执行。3.wait() 方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 notify() 或者 notifyAll() 方法。sleep() 方法执行完成后，线程会自动苏醒。<br>&nbsp;&nbsp;&nbsp;&nbsp;共同点：两者都可以暂停线程的执行<br><b style="color: #6A6AFF">7.启动一个线程为什么用start，不用run？</b><br>&nbsp;&nbsp;&nbsp;&nbsp;new 一个 Thread，线程进入了新建状态;调用 start() 方法，会启动一个线程并使线程进入了就绪状态，当分配到时间片后就可以开始运行了。 start() 会执行线程的相应准备工作，然后自动执行 run() 方法的内容，这是真正的多线程工作。 而直接执行 run() 方法，会把 run 方法当成一个 main 线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作。<br>&nbsp;&nbsp;&nbsp;&nbsp;总结：调用 start 方法方可启动线程并使线程进入就绪状态，而 run 方法只是 thread 的一个普通方法调用，还是在主线程里执行。<br><b style="color: #6A6AFF">8.线程同步的方法(<a href="https://my.oschina.net/locust/blog/2244731" target="_blank" rel="noopener">https://my.oschina.net/locust/blog/2244731</a>)</b><br>&nbsp;&nbsp;&nbsp;&nbsp;1.同步方法：即有synchronized关键字修饰的方法。由于java的每个对象都有一个内置锁，当用此关键字修饰方法时，内置锁会保护整个方法。在调用该方法前，需要获得内置锁，否则就处于阻塞状态。<label style="color:red">注：synchronized关键字也可以修饰静态方法，此时如果调用该静态方法，则会锁住整个类</label><br>&nbsp;&nbsp;&nbsp;&nbsp;2.同步代码块：即有synchronized关键字修饰的语句块。被该关键字修饰的语句块会自动被加上内置锁，从而实现同步。<label style="color:red">注：同步是一种高开销的操作，因此应该尽量减少同步的内容。通常没有必要同步整个方法，使用synchronized代码块同步关键代码即可</label><br>&nbsp;&nbsp;&nbsp;&nbsp;3.使用特殊域变量(volatile)实现线程同步<label style="color:red">(注：多线程中的非同步问题主要出现在对域的读写上，如果让域自身避免这个问题，则就不需要修改操作该域的方法。用final域、有锁保护的域和volatile域可以避免非同步的问题)</label>：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;①volatile关键字为域变量的访问提供了一种免锁机制<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;②使用volatile修饰域相当于告诉虚拟机该域可能会被其他线程更新<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;③因此每次使用域就要重新计算，而不是使用寄存器中的值<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;④volatile不会提供任何原子操作，它也不能用来修饰final类型的变量<br>&nbsp;&nbsp;&nbsp;&nbsp;4.使用重入锁实现线程同步：在jdk5中新增一个java.util.concurrent包来支持同步。ReentrantLock类是可重入、互斥、实现Lock接口的锁，它与使用synchronized方法和块具有相同的基本行为和语义，并扩展了其能力。ReetrantLock类的常用方法有:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ReetrantLock():创建一个ReetrantLock实例<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lock():获得锁<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unlock():释放锁<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<label style="color:red">注：关于Lock对象和synchronized关键字的选择:①.最好两个都不用，使用一种java.util.concurrent包提供的机制，能够帮助用户处理所有与锁相关的代码。②.如果synchronized关键字能够满足用户的需求，就用synchronized，因为它能简化代码。③.如果需要更高级功能，就用ReetrantLock类，此时要注意及时释放锁，否则会出现死锁，通常在finally代码释放锁</label><br>&nbsp;&nbsp;&nbsp;&nbsp;5.使用局部变量实现线程同步:如果使用ThreadLocal管理变量，则每一个使用该变量的线程都获得该变量的副本，副本之间相互独立，这样每一个线程都可以随意修改自己的变量副本，而不会对其他线程产生影响。ThreadLocal类的常用方法：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ThreadLocal():创建一个线程本地变量<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get():返回此线程局部变量的当前线程副本的值<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;initalValue():返回此线程局部变量的当前线程的初始值<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;set(T value):将此线程局部变量的当前线程副本的值设置为value<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<label style="color:red">注：ThreadLocal与同步机制:①.ThreadLocal与同步机制都是为了解决多线程中相同变量的访问冲突问题。②.前者采用以空间换时间的方法，后者采用以时间换空间的方式</label><br>&nbsp;&nbsp;&nbsp;&nbsp;6.实现阻塞队列实现线程同步：前5种同步方式都是在底层实现的线程同步，但是我们实际开发当中，应当尽量原理底层结构。使用java.util.concurrent包有助于简化开发。LinkedBlockingQueue类常用方法:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LinkedBlockingQueue():创建一个容量为Integer.MAX_VALUE的LinkedBlockingQueue<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;put(E e):在队尾添加一个元素，如果队列满则阻塞<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;size():返回队列中的元素个数<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;take():移除并返回队头元素，如果队列空则阻塞<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<label style="color:red">注：BlockingQueue&lt;E&gt;定义了阻塞队列的常用方法，尤其是三种添加元素的方法，我们需要多加注意，当队列满时：add()方法会抛出异常，offer()方法返回false，put()方法会阻塞</label><br>&nbsp;&nbsp;&nbsp;&nbsp;7.使用院子变量实现线程同步:需要使用线程同步的根本原因在于对普通变量的操作不是原子的。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;原子操作:是指将读取变量值、修改变量值、保存变量值看成一个整体来操作，即这几种行为要么同时完成，要么都不完成。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在java中util.concurrent.atomic包中提供了创建原子类型变量的工具类，使用该类可以简化线程同步。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其中AtomicInteger表可以用原子方式更新int的值，可用在应用程式中(如以原子方式增加的计数器)，但不能用于替换Integer；可扩展Number，允许那些处理基于数字类的工具和实用工具进行统一访问。AtomicInteger类常用方法:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;AtomicInteger(int initalValue):创建具有给定初始值的新的AtomicInteger<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;addAddGet(int dalta):以原子方式将给定值与当前值相加<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get():获取当前值<br><b style="color: #6A6AFF">9.synchronized与lock的区别</b><br>&nbsp;&nbsp;&nbsp;&nbsp;①.lock是一个接口，而synochronized是java的一个内置关键字。<br>&nbsp;&nbsp;&nbsp;&nbsp;②.异常是否释放锁:synchronized在放生异常时会自动释放占有的锁，因此不会出现死锁；而lock发生异常时，不会主动释放占有的锁，必须手动unlock来释放锁，可能引起死锁的发生(所以最好将同步代码块用try catch包起来，finally中写入unlock，避免死锁的发生)<br>&nbsp;&nbsp;&nbsp;&nbsp;③.是否知道获取锁:lock可以通过trylock来知道有没有获取锁，而synchronized不能。<br>&nbsp;&nbsp;&nbsp;&nbsp;④.synchronized和lock的用法区别:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;synchronized:在需要同步的对象中加入此控制，synchroized可以加在方法上，也可以加在特定代码块上，括号中表示需要锁的对象。普通同步方法，锁的是当前实例对象；静态同步方法，锁的是当前类的class对象；同步方法块，锁的是括号里面的对象。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lock：一般使用ReentrantLock类作为锁。在加锁和解锁处需要通过lock()和unlock()显示指出。所以一般会在finally块中写unlock()以防死锁。<br>&nbsp;&nbsp;&nbsp;&nbsp;⑤.2种锁的具体区别：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;synchronized原始采用的是CPU悲观锁机制，即线程获得的是独占锁。独占锁意味着其他线程只能依靠阻塞来等待线程释放锁。而在CPU转换线程阻塞时会引起线程上下文切换，当有很多线程竞争锁的时候，会引起CPU频繁的上下文切换导致效率很低。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lock用的是乐观锁。所谓的乐观锁就是每次不加锁，而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，知道成功为止。乐观锁实现的机制就是CAS操作。<br><b style="color: #6A6AFF">10.在java中守护线程和本地线程区别？</b><br>&nbsp;&nbsp;&nbsp;&nbsp;java中线程分为两种：守护线程(Daemon)和用户线程(User)。<br>&nbsp;&nbsp;&nbsp;&nbsp;任何线程都可以设置为守护线程和用户线程，通过方法Thread.setDaemon(bool on);true则把该线程设置为守护线程，反之则为用户线程。Thread.setDaemon()必须在Thread.start()之前调用，否则运行时会抛出异常。<br>&nbsp;&nbsp;&nbsp;&nbsp;<b style="color: #00FFFF">两者的区别：</b><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;唯一的区别是判断虚拟机(JVM)何时离开，Daemon是为其他线程提供服务，如果全部的UserThread已经撤离，Daemon没有可服务的线程，JVM撤离。也可以理解为守护线程是JVM自动创建的线程(但不一定)，用户线程是程序创建的线程；比如JVM的垃圾回收线程是一个守护线程，当所有线程已经撤离，不再产生垃圾，守护线程自然就没事可干了，当垃圾回收线程是Java虚拟机上仅剩的线程时，Java虚拟机会自动离开。<br>&nbsp;&nbsp;&nbsp;&nbsp;<b style="color: #00FFFF">扩展：</b>Thread Dump打印出的线程信息，含有daemon字样的线程即为守护线程，可能会有：服务守护进程、编译守护进程、windows下的监听Ctrl+break的守护进程、Finalizer守护进程、引用处理守护进程、GC守护进程。<br><b style="color: #6A6AFF">11.线程和进程的区别？</b><br>&nbsp;&nbsp;&nbsp;&nbsp;进程是操作系统分配资源的最小单元，线程是操作系统调度的最小单元。<br>&nbsp;&nbsp;&nbsp;&nbsp;一个程序至少有一个进程，一个进程至少有一个线程。<br><b style="color: #6A6AFF">12.什么是多线程中的上下文切换？</b><br>&nbsp;&nbsp;&nbsp;&nbsp;多线程会共同使用一组计算机上的CPU，而线程数大于给程序分配的CPU数量时，为了让各个线程都有执行的机会，就需要轮转使用CPU。不同的线程切换使用CPU发生的切换数据等就是上下文切换。<br><b style="color: #6A6AFF">13.死锁和活锁的区别，死锁和饥饿的区别？</b><br>&nbsp;&nbsp;&nbsp;&nbsp;<b style="color: #00FFFF">死锁：</b>是指两个或两个以上的进程(或线程)在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，他们都将无法推进下去。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;产生死锁的必要条件：</p>
<ul>
<li>互斥条件：所谓互斥就是进程在某一时间内独占资源。</li>
<li>请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。</li>
<li>不剥夺条件：进程已获得资源，在未使用完之前，不能强制剥夺。</li>
<li>循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。<br>&nbsp;&nbsp;&nbsp;&nbsp;<b style="color: #00FFFF">活锁：</b>任务或者执行者没有被阻塞，由于某些条件没有满足，导致一直重复尝试，失败，尝试，失败。<br>&nbsp;&nbsp;&nbsp;&nbsp;活锁和死锁的区别在于，处于活锁的实体是在不断的改变状态，所谓的“活”，而处于死锁的实体表现为等待；活锁有可能自行解开，死锁则不能。<br>&nbsp;&nbsp;&nbsp;&nbsp;<b style="color: #00FFFF">饥饿：</b>一个或者多个线程因为种种原因无法获得所需要的资源，导致一直无法执行的状态。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Java中导致饥饿的原因：</li>
<li>高优先级线程吞噬所有的低优先级线程的CPU时间。</li>
<li>线程被永久堵塞在一个等待进入同步块的状态，因为其他线程总是能在它之前持续地对该同步块进行访问。</li>
<li>线程在等待一个本身也处于永久等待完成的对象(比如调用这个对象的wait方法)，因为其他线程总是被持续地获得唤醒。<br><b style="color: #6A6AFF">14.java中用到的线程调度算法是什么？</b><br>&nbsp;&nbsp;&nbsp;&nbsp;采用时间片轮转的方式。可以设置线程的优先级，会映射到下层的系统上面的优先级上，如非特别需要，尽量不要用，防止线程饥饿。<br><b style="color: #6A6AFF">15.什么是线程组，为什么在java中不推荐使用？</b><br>&nbsp;&nbsp;&nbsp;&nbsp;ThreadGroup类，可以把线程归属到某一个线程组中，线程组中可以有线程对象，也可以有线程组，组中还可以有线程，这样的组织结构有点类似于树的形式。<br>&nbsp;&nbsp;&nbsp;&nbsp;为什么不推荐使用？因为使用有很多的安全隐患，没有具体追究，如果需要使用，推荐使用线程池。<br><b style="color: #6A6AFF">16.为什么使用Executor框架</b><br>&nbsp;&nbsp;&nbsp;&nbsp;1.每次执行任务创建线程new Thread()比较消耗性能，创建一个线程是比较耗时、耗资源的。<br>&nbsp;&nbsp;&nbsp;&nbsp;2.调用new Thread()创建的线程缺乏管理，被称为野线程，而且可以无限制的创建，线程之间的相互竞争会导致过多占用系统资源而导致系统瘫痪，还有线程之间的频繁交替也会消耗很多系统资源。<br>&nbsp;&nbsp;&nbsp;&nbsp;3.使用new Thread()启动的线程不利于扩展，比如定时执行、定期执行、定时定期执行、线程中断等都不便实现。<br><b style="color: #6A6AFF">17.在java中Executor和Executors的区别？</b><br>&nbsp;&nbsp;&nbsp;&nbsp;Executors工具类的不同方法按照我们的需求创建了不同的线程池，来满足业务的需求。<br>&nbsp;&nbsp;&nbsp;&nbsp;Executor接口对象能执行我们的线程任务。<br>&nbsp;&nbsp;&nbsp;&nbsp;ExecutorService接口继承了Executor接口并进行了扩展，提供了更多的方法，我们能获得任务执行的状态并且可以获取任务的返回值。<br>&nbsp;&nbsp;&nbsp;&nbsp;使用ThreadPoolExecutor可以创建自定义线程池。<br>&nbsp;&nbsp;&nbsp;&nbsp;Future表示异步计算的结果，它提供了检查计算是否完成的方法，以等待计算的完成，并可以使用get()方法获取计算的结果。<br><b style="color: #6A6AFF">18.什么是原子操作？在Java Concurrency API中有哪些原子类(atomic classes)</b><br>&nbsp;&nbsp;&nbsp;&nbsp;原子操作(atomic operation)意为“不可被中断的一个或者一系列”。<br>&nbsp;&nbsp;&nbsp;&nbsp;处理器使用基于对缓存加锁或总线加锁的方式来实现多处理器之间的原子操作。<br>&nbsp;&nbsp;&nbsp;&nbsp;在java中可以通过加锁和循环CAS的方式来实现原子操作。CAS操作–Compare&amp;Set，或是Compare&amp;Swap，现在几乎所有的CPU指令操作。<br>&nbsp;&nbsp;&nbsp;&nbsp;原子操作是指一个不受其他操作的操作任务单元。原子操作是在多线程环境下避免数据不一致必须的手段。<br>&nbsp;&nbsp;&nbsp;&nbsp;int++并不是一个原子操作，所以当一个线程读取它的值并加1时，另外一个线程可能会读到之前的值，这就会引发错误。<br>&nbsp;&nbsp;&nbsp;&nbsp;为了解决这个问题，必须保证增加操作是原子的，在JDK1.5之前我们可以使用同步技术来做到这一点。到JDK1.5，java.util.Concurrent.atomic包提供了int和long类型的原子包装类，它们可以自动的保证对于它们的操作是原子的并且不需要使用同步。<br>&nbsp;&nbsp;&nbsp;&nbsp;java.util.concurrent这个包里面提供了一组原子类。其基本的特性就是在多线程环境下，当有多个线程同时执行这些类的实例包含的方法，具有排他性，即当某个线程进入方法，执行其中的指令时，不会被其他的线程打断，而别的线程就会像自旋锁一样，一直等到该方法执行完成，才由JVM从等待队列中选择一个另一个进程进入吗，这只是一种逻辑上的理解。<br>&nbsp;&nbsp;&nbsp;&nbsp;原子类：AtomicBoolean,AtomicInteger,AtomicLong,AtomicReference<br>&nbsp;&nbsp;&nbsp;&nbsp;原子数组：AtomicIntegerArray,AtomicLongArray,AtomicReferenceArray<br>&nbsp;&nbsp;&nbsp;&nbsp;原子属性更新器：AtomicLongFieldUpdater,AtomicIntegerFieldUpdater,AtomicReferenceFieldUpdater<br>&nbsp;&nbsp;&nbsp;&nbsp;解决ABA问题的原子类：AtomicMarkableReference(通过引入一个boolean来反映中间有没有变过)，AtomicStampedReference(通过引入一个int累加来反映中间有没有变过)<br><b style="color: #6A6AFF">19.Java Concurrency API中的Lock接口(Lock interface)是什么？对比同步它有什么优势？</b><br>&nbsp;&nbsp;&nbsp;&nbsp;Lock接口比同步方法和同步块提供了更具拓展性的锁操作。<br>&nbsp;&nbsp;&nbsp;&nbsp;它们允许更灵活的结构，可以具有完全不同的性质，并且可以支持多个相关类的条件对象。<br>&nbsp;&nbsp;&nbsp;&nbsp;它的优势有：</li>
<li>可以使锁更公平</li>
<li>可以使线程在等待锁的时候响应中断</li>
<li>可以让线程尝试获取锁，并在无法获取锁的时候立即返回或者等待一段时间</li>
<li>可以在不同的范围，以不同顺序获取和释放锁<br>&nbsp;&nbsp;&nbsp;&nbsp;整体上来说Lock是synchronized的扩展版，Lock提供了无条件的、可轮询的(tryLock方法)、定时的(tryLock带参方法)、可中断的(lockInterruptibly)、可多条件队列的(newCondition方法)锁操作。另外Lock的实现类基本都支持非公平锁(默认)和公平锁，synchronized只支持非公平锁的，当然，在大部分情况下，非公平锁是高效的选择。<br><b style="color: #6A6AFF">20.什么是Executors框架</b><br>&nbsp;&nbsp;&nbsp;&nbsp;Executor框架是一个根据一组执行策略调用、调度、执行和控制的异步任务的框架。<br>&nbsp;&nbsp;&nbsp;&nbsp;无限制的创建线程会引起应用程序内存溢出。所以创建一个线程池是一个更好的解决方案，因为可以限制线程的数量并且可以回收再利用这些线程。利用Executors框架可以非常方便的创建一个线程池。<br><b style="color: #6A6AFF">21.什么是阻塞队列？阻塞队列的实现原理是什么？如何使用阻塞队列来实现生产者-消费者模型？</b><br>&nbsp;&nbsp;&nbsp;&nbsp;阻塞队列(BlockingQueue)是一个支持两个附加操作的队列。<br>&nbsp;&nbsp;&nbsp;&nbsp;这两个附加操作是：在队列为空时，获取元素的线程会等待队列变为非空。当队列满时，存储元素的线程会等待队列可用。<br>&nbsp;&nbsp;&nbsp;&nbsp;阻塞队列常用于生产者和消费者的场景，生产者是往队列里添加元素的线程，消费者是从队列里拿元素的线程。阻塞队列就是生产者存放元素的容器，而消费者也只从容器里拿元素。<br>&nbsp;&nbsp;&nbsp;&nbsp;JDK7提供了7个阻塞队列，分别是：</li>
<li>ArrayBlockingQueue:一个由数组结构组成的有界阻塞队列。</li>
<li>LinkedBlockingQueue:一个由链表结构组成的有界阻塞队列。</li>
<li>PriorityBlockingQueue:一个支持优先级排序的无界阻塞队列。</li>
<li>DelayQueue:一个支持优先级队列实现的无界阻塞队列。</li>
<li>SynchronousQueue:一个不存储元素的阻塞队列。</li>
<li>LinkedTransferQueue:一个由链表结构组成的无界阻塞队列。</li>
<li>LinkedBlockingDeque:一个由链表结构组成的双向阻塞队列。<br>&nbsp;&nbsp;&nbsp;&nbsp;JDK5之前实现同步存取时，可以使用普通的一个集合，然后在使用线程的协作和线程同步可以实现生产者，消费者模式，主要的技术就是用好wait、notify、notifyAll、synchronized这些关键字。而在JDK5之后，可以使用阻塞队列来实现，此方式大大减少了代码量，使得多线程编程更加容易，安全方面也有保障。<br>&nbsp;&nbsp;&nbsp;&nbsp;BlockingQueue接口是Queue的子接口，它的主要用途并不是作为容器，而是作为线程同步的工具，因此它具有一个很明显的特性，当生产者线程试图向BlockingQueue放入元素时，如果队列已满，则线程会被阻塞，当消费者试图从中取出一个元素时，如果队列为空，则该线程会被阻塞，正是因为它所具有这个特性，所以在程序中多个线程交替向BlockingQueue中放入元素、取出元素，它可以很好的控制线程之间的通信。<br>&nbsp;&nbsp;&nbsp;&nbsp;阻塞队列使用最经典的场景就是socket客户端数据的读取和解析，读取数据的线程不断将数据放入队列，然后解析线程不断从队列中取数据解析。<br><b style="color: #6A6AFF">21.什么是Callable和Future?</b><br>&nbsp;&nbsp;&nbsp;&nbsp;Callable接口类似于Runnable，从名字就可以看出来了，但是Runnable不会返回结果，并且无法抛出返回结果的异常，而Callable功能更强大一些，被线程执行后，可以返回值，这个返回值可以被Future拿到，也就是说，Future可以拿到异步执行任务的返回值。可以认为是带有回调的Runnable。<br>&nbsp;&nbsp;&nbsp;&nbsp;Future接口表示异步任务，是还没有完成的任务给出的未来结果。所以说Callable用于产生结果，Future用于获取结果。<br><b style="color: #6A6AFF">22.什么是FutureTask?使用ExecutorService启动任务。</b><br>&nbsp;&nbsp;&nbsp;&nbsp;在Java并发程序中FutureTask表示一个可以取消的异步运算。它有启动和取消运算、查询运算是否完成和取回运算结果等方法。只有当运算完成的时候结果才能取回，如果运算尚未完成get方法将会阻塞。一个FutureTask对象可以对调用了Callable和Runnaable的对象进行包装，由于FutureTask也是调用了Runnable接口，所以它可以提交给Executor来执行。<br><b style="color: #6A6AFF">23.什么是并发容器的实现？</b><br>&nbsp;&nbsp;&nbsp;&nbsp;何为同步容器：可以简单地理解为通过synchronized来实现同步的容器，如果有多个线程调用同步容器的方法，它们将会串行执行。比如Vector、Hashtable以及Collections.synchronizedSet、synchronizedList等方法返回的容器。<br>&nbsp;&nbsp;&nbsp;&nbsp;可以通过查看Vevtor、Hashtable等这些同步容器的实现代码，可以看到这些容器实现线程安全的方式就是将他们的状态封装起来，并在需要同步的方法上加上关键字synchronized。<br>&nbsp;&nbsp;&nbsp;&nbsp;并发容器使用了与同步容器完全不同的加锁策略来提供更高的并发性和伸缩性，例如在ConcurrentHashMap中采用了一种粒度更细的加锁机制，可以称为分段锁，在这种锁机制下，允许任意数量的读线程并发地访问map，并且执行读操作的线程和写操作的线程也可以并发的访问map，同时允许一定数量的写操作线程并发地修改map，所以它可以在并发环境下实现更高的吞吐量。<br><b style="color: #6A6AFF">24.多线程同步和互斥有几种实现方法，都是什么？</b><br>&nbsp;&nbsp;&nbsp;&nbsp;线程同步是指线程之间所具有的一种制约关系，一个线程的执行依赖另一个线程的消息，当它没有得到另一个线程的消息时应等待，直到消息到达时才被唤醒。<br>&nbsp;&nbsp;&nbsp;&nbsp;线程互斥是指对于共享的进程系统资源，在各单个线程访问时的排他性。当有若干个线程都要使用某一共享资源时，任何时刻最多只允许一个线程去使用，其他要使用该资源的线程必须等待，直到占用资源者释放该资源。线程互斥可以看成是一种特殊的线程同步。<br>&nbsp;&nbsp;&nbsp;&nbsp;线程间的同步方法大体可分为两类：用户模式和内核模式。顾名思义，内核模式就是指利用系统内核对象的单一性来进行同步，使用时需要切换内核态与用户态，而用户模式就是不需要切换到内核态，只在用户态完成操作。<br>&nbsp;&nbsp;&nbsp;&nbsp;用户模式下的方法有：原子操作(例如一个单一的全局变量)，临界区。内核模式下的方法有：事件，信号量，互斥量。<br><b style="color: #6A6AFF">25.什么是竞争条件？你怎么发现和解决竞争？</b><br>&nbsp;&nbsp;&nbsp;&nbsp;当多个进程都企图对共享数据进行某种处理，而最后的结果又取决于进程运行的顺序时，则我们认为这发生了竞争条件(race condition)。<br><b style="color: #6A6AFF">26.Java中你怎样唤醒一个阻塞的线程？</b><br>&nbsp;&nbsp;&nbsp;&nbsp;在Java发展史上曾经使用suspend()、resume()方法对于线程进行阻塞唤醒，但随之出现很多问题，比较典型的还是死锁问题。<br>&nbsp;&nbsp;&nbsp;&nbsp;解决方案可以使用以对象为目标的阻塞，即利用Object类的wait()和notify()方法实现线程阻塞。<br>&nbsp;&nbsp;&nbsp;&nbsp;首先，wait、notify方法是针对对象的，调用任意对象的wait()方法都将导致线程阻塞，阻塞的同时也将释放该对象的锁，相应的，调用任意对象的notify()方法则将随机解除该对象阻塞的线程，但它需要重新获取该对象的锁，直到获取成功才能往下执行；其次，wait、notify方法必须在synchronized块或方法中被调用，并且要保证同步块或方法的锁对象与调用wait、notify方法的对象是同一个，如此一来在调用wait之前当前线程就已经成功获取某对象的锁，执行wait阻塞后当前线程就将之前获取的对象锁释放。<br><b style="color: #6A6AFF">27.在Java中CycliBarrier和CountdownLatch有什么区别？</b><br>&nbsp;&nbsp;&nbsp;&nbsp;CycliBarrier可以重复使用，而CountdownLatch不能重复使用。<br>&nbsp;&nbsp;&nbsp;&nbsp;Java的concurrent包里面的CountdownLatch其实可以把它看作一个计数器，只不过这个计数器的操作是原子操作，同时只能有一个线程去操作这个计数器，也就是同时只能有一个线程去减这个计数器里面的值。<br>&nbsp;&nbsp;&nbsp;&nbsp;你可以向CountdownLatch对象设置一个初始的数字作为计数值，任何调用这个对象上的await()方法都会阻塞，直到这个计数器的计数值被其他的线程减为0为止。<br>&nbsp;&nbsp;&nbsp;&nbsp;所以在当前计数到达到零之前，await方法会一直受阻塞。之后，会释放所有等待的线程，await的所有后续调用都将立即返回。这种现象只出现一次–计数无法被重置。如果需要重置计数，请考虑使用CyclicBarrier。<br>&nbsp;&nbsp;&nbsp;&nbsp;CountdownLatch的一个非常典型的应用场景是：有一个任务想要往下执行，但必须要等到其他的任务执行完毕后才可以继续往下执行。假如我们这个想要继续往下执行的任务调用一个CountdownLatch对象的await()方法，其他的任务执行完自己的任务后调用同一个CountdownLatch对象上的countDown()方法，这个调用await()方法的任务将一直阻塞等待，直到这个CountdownLatch对象的计数值减到0为止。<br>&nbsp;&nbsp;&nbsp;&nbsp;CyclicBarrier一个同步辅助类，它允许一组线程互相等待，直到到达某个公共屏障点(common barrier point)。在涉及一组固定大小的线程的程序中，这些线程必须不时地互相等待，此时CyclicBarrier很有用。因为该barrier在释放等待线程后可以重用，所以称它为循环的barrier。<br><b style="color: #6A6AFF">28.什么是不可变对象，它对写并发应用有什么帮助？</b><br>&nbsp;&nbsp;&nbsp;&nbsp;不可变对象(Immutable Objects)即对象一旦被创建它的状态(对象的数据，也即对象属性值)就不能改变，反之即为可变对象(Mutable Objects)。<br>&nbsp;&nbsp;&nbsp;&nbsp;不可变对象的类即为不可变类(Immutable Class)。Java平台类库中包含许多不可变类，如String、基本类型的包装类、BigInteger和BigDecimal等。<br>&nbsp;&nbsp;&nbsp;&nbsp;不可变对象天生是线程安全的。它们的常量(域)是在构造函数中创建的。既然它们的状态无法修改，这些常量永远不会变。<br>&nbsp;&nbsp;&nbsp;&nbsp;不可变对象永远是线程安全的。<br>&nbsp;&nbsp;&nbsp;&nbsp;只有满足如下状态，一个对象才是不可变的：</li>
<li>它的状态不能在创建后再被修改；</li>
<li>所有域都是final类型；</li>
<li>它被正确创建(创建期间没有发生this引用的逸出)<br><b style="color: #6A6AFF">29.什么是多线程中的上下文切换？</b><br>&nbsp;&nbsp;&nbsp;&nbsp;在上下文切换过程中，CPU会停止处理当前运行的程序，并保存当前程序运行的具体位置以便之后继续运行。从这个角度来看，上下文切换有点像我们同时阅读几本书，在来回切换书本的同时我们需要记住每本书当前读到的页码。在程序中，上下文切换过程中的”页码”信息是保存在进程控制块(PCB)中的。PCB还经常被称作”切换桢”(switchframe)。”页码”信息会一直保存到CPU的内存中，直到它们被再次使用。<br>&nbsp;&nbsp;&nbsp;&nbsp;上下文切换是存储和恢复CPU状态的过程，它使得线程执行能够从中断点恢复执行。上下文切换是多任务操作系统和多线程环境的基本特征。</li>
</ul>

      
    </div>
    
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2019/11/07/集群-分布式环境下5种共享session处理策略/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">&lt;</strong>
      <div class="article-nav-title">
        
          集群/分布式环境下5种共享session处理策略
        
      </div>
    </a>
  
  
    <a href="/2019/11/07/interview_nginx/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">面试题-nginx</div>
      <strong class="article-nav-caption">&gt;</strong>
    </a>
  
</nav>

  
</article>



</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
      <div class="footer-left">
        &copy; 2020 Will Wu
      </div>
        <div class="footer-right">
          <a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/smackgg/hexo-theme-smackdown" target="_blank">Smackdown</a>
        </div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: false,
		isPost: true,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="/js/main.js"></script>



<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js"></script>


  </div>
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"model":{"jsonPath":"/live2dw/assets/miku.model.json"},"display":{"position":"left","width":150,"height":300},"mobile":{"show":false},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>

</html>